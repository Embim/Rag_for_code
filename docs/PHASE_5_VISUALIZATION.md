# Фаза 5. Визуализация

## Общее описание фазы

Это самая инновационная часть проекта — превращение найденного кода в визуальную документацию. Вместо того чтобы просто показать код эндпоинта и компонента, система делает скриншот реального интерфейса, рисует стрелку на кнопку которую нужно нажать, показывает диаграмму потока данных, и объясняет каждый шаг.

Результат фазы — система умеет запускать фронтенд-приложение, делать аннотированные скриншоты, генерировать диаграммы из графа знаний, и собирать всё это в пошаговые инструкции.

---

## TODO 5.1: Рендеринг UI через Playwright

### Что нужно сделать

Реализовать модуль, который запускает React-приложение в headless-браузере и делает скриншоты нужных страниц.

### Почему Playwright

Playwright — современный инструмент для автоматизации браузеров. Преимущества перед Puppeteer: нативная поддержка Python (не нужен Node.js bridge), лучшая работа с современными SPA, встроенная поддержка ожидания загрузки, скриншоты с высоким разрешением.

### Запуск фронтенд-приложения

Перед созданием скриншотов нужно запустить приложение. Варианты:

Development mode: npm run dev / yarn dev. Быстро запускается, есть hot reload, но может отличаться от production.

Production build: npm run build && npm run start или serve -s build. Ближе к реальному приложению, но дольше собирается.

Для документации обычно достаточно development mode. Приложение запускается в фоновом процессе, Playwright подключается к нему.

### Docker-изоляция

Запуск чужого кода — потенциальный риск безопасности. Приложение запускается в Docker-контейнере с ограниченными правами. Контейнер имеет доступ только к коду репозитория, изолирован от сети (кроме localhost для API), не имеет доступа к файловой системе хоста.

Базовый образ: node:20-slim для Node.js приложений. В контейнере устанавливаются зависимости через npm install и запускается dev server.

### Мокирование API

Фронтенд-приложение обычно требует работающий бэкенд. Варианты решения:

Запустить и бэкенд тоже — сложнее, но даёт реальные данные. Требует настройки базы данных, миграций, тестовых данных.

Мокировать API — проще, достаточно для большинства случаев документации. Используется Playwright route interception или MSW (Mock Service Worker).

Для мокирования нужны тестовые данные. Они могут быть заданы вручную для демо-сценариев, или сгенерированы автоматически на основе Pydantic/Django моделей.

### Навигация по приложению

Playwright позволяет навигировать по SPA: открыть URL, кликнуть по ссылке, заполнить форму. Для создания скриншота нужной страницы: определить URL из RouteNode графа, открыть этот URL, дождаться загрузки (networkidle или появление определённого элемента).

### Обработка динамического контента

React-приложения рендерятся динамически. Скриншот нужно делать после полной загрузки. Playwright предоставляет методы ожидания: waitForLoadState('networkidle'), waitForSelector('.main-content'), waitForFunction для кастомных условий.

Для интерактивных элементов (dropdown, modal) нужно сначала выполнить действие которое их показывает, затем делать скриншот.

---

## TODO 5.2: Аннотирование скриншотов

### Что нужно сделать

Реализовать модуль, который добавляет на скриншоты визуальные аннотации: обводки элементов, стрелки, номера шагов, текстовые подписи.

### Нахождение элементов на странице

Для аннотации элемента нужно знать его координаты на скриншоте. Playwright позволяет получить bounding box элемента: page.locator("button.submit").bounding_box() возвращает {x, y, width, height}.

Элемент находится по селектору. Селектор может быть: CSS-селектором (.btn-primary), data-атрибутом ([data-testid="submit-button"]), текстом (text="Отправить"), XPath.

### Связь с исходным кодом

Ключевая возможность системы — связать элемент на странице с кодом компонента. Из графа знаний известно, что компонент SubmitButton рендерит кнопку с классом .btn-submit. Используем этот класс как селектор для поиска элемента на странице.

Если в коде есть data-testid (хорошая практика для тестирования), используем его — это самый надёжный селектор.

### Типы аннотаций

Обводка элемента — прямоугольник вокруг элемента, привлекает внимание. Параметры: цвет, толщина линии, скругление углов.

Стрелка к элементу — стрелка от края скриншота к элементу. Параметры: направление (сверху, слева, снизу, справа), цвет, стиль (прямая, изогнутая).

Номер шага — кружок с цифрой рядом с элементом, для пошаговых инструкций.

Текстовая подпись — текст рядом с элементом, объясняющий что делать. Параметры: текст, позиция относительно элемента, шрифт, цвет фона.

Затемнение фона — всё кроме целевого элемента затемняется, фокусирует внимание.

### Технология рисования

Pillow (PIL) — стандартная библиотека для работы с изображениями в Python. Достаточна для базовых аннотаций: прямоугольники, линии, текст.

Для более сложных аннотаций (изогнутые стрелки, тени, градиенты) можно использовать cairo через pycairo или wand (ImageMagick binding).

### Позиционирование подписей

Автоматический выбор позиции для подписи чтобы она не перекрывала важные элементы. Алгоритм: попробовать позиции (справа, снизу, слева, сверху), выбрать ту где меньше пересечение с другими элементами и контентом страницы.

### Масштабирование

Скриншоты делаются в определённом разрешении (например, 1920x1080). Для отображения в документации может понадобиться масштабирование. Координаты аннотаций должны масштабироваться вместе с изображением.

---

## TODO 5.3: Генерация диаграмм

### Что нужно сделать

Реализовать автоматическую генерацию диаграмм из графа знаний для визуализации потоков данных и архитектуры.

### Формат Mermaid

Mermaid — текстовый формат для описания диаграмм, который рендерится в SVG. Преимущества: простой синтаксис, поддержка в GitHub/GitLab, множество типов диаграмм, легко генерировать программно.

Система генерирует Mermaid-код, который затем рендерится в изображение для включения в документацию.

### Sequence Diagrams

Для отображения потока запроса через систему. Участники: User, Frontend, API, Backend, Database. Сообщения между участниками показывают вызовы и ответы.

Генерация: из цепочки связей в графе (Component → SENDS_REQUEST_TO → Endpoint → CALLS → Service → USES_MODEL → Model) строится последовательность участников и сообщений.

Пример генерируемого кода:
```
sequenceDiagram
    User->>CartButton: click
    CartButton->>API: POST /cart/items
    API->>CartService: add_item()
    CartService->>Database: INSERT cart_item
    Database-->>CartService: item_id
    CartService-->>API: CartItem
    API-->>CartButton: 201 Created
    CartButton->>User: show notification
```

### Flowcharts

Для отображения логики функции или процесса. Узлы — шаги, рёбра — переходы. Условные ветвления показываются ромбами.

Генерация сложнее — нужно анализировать AST функции и извлекать control flow. Для простых случаев (линейная последовательность вызовов) достаточно.

### Entity Relationship Diagrams

Для отображения структуры данных. Сущности — модели, связи — ForeignKey/ManyToMany. Поля показываются внутри сущностей.

Генерация: из ModelNode графа извлекаются поля и связи. Mermaid ER diagram синтаксис описывает сущности и их отношения.

### Component Diagrams

Для отображения архитектуры фронтенда или бэкенда. Компоненты/модули как блоки, зависимости как стрелки.

Генерация: из графа извлекаются группы файлов (по директориям), вычисляются зависимости между группами, строится диаграмма модулей.

### Рендеринг Mermaid

Варианты рендеринга Mermaid в изображение:

mermaid-cli (mmdc) — официальный CLI инструмент. Требует Node.js, вызывается через subprocess.

Mermaid Live Editor API — онлайн сервис, можно отправить код и получить SVG/PNG.

kroki.io — универсальный сервис для рендеринга диаграмм, поддерживает Mermaid.

Рекомендуется mermaid-cli для оффлайн работы, kroki.io как fallback.

---

## TODO 5.4: Генератор пошаговых инструкций

### Что нужно сделать

Реализовать модуль, который собирает найденный код, скриншоты и диаграммы в связный пошаговый гайд.

### Структура шага

Каждый шаг инструкции содержит:

Номер и заголовок — "Шаг 1: Нажмите кнопку Добавить в корзину"

Описание — текстовое объяснение что происходит на этом шаге

Визуальный контент — скриншот с аннотациями, диаграмма, или блок кода

Связи с кодом — ссылки на файлы и строки исходного кода

### Определение последовательности шагов

Для вопросов типа "как сделать X" последовательность определяется по потоку данных:

Шаги на фронте: навигация к нужной странице → действие пользователя (клик, ввод) → отправка запроса.

Шаги на бэке: получение запроса → валидация → бизнес-логика → сохранение в базу → формирование ответа.

Шаги результата: получение ответа на фронте → обновление UI → уведомление пользователя.

Каждый шаг сопровождается либо скриншотом (для UI шагов), либо диаграммой/кодом (для backend шагов).

### Генерация текстовых описаний

Текст для каждого шага генерируется LLM на основе контекста: кода сущности, её типа, связей. Промпт включает: "Опиши на русском языке что делает этот код в контексте пользовательского действия {action}".

Стиль описания — как инструкция для разработчика, не слишком технический, но с упоминанием ключевых деталей.

### Группировка связанных шагов

Слишком много мелких шагов делает инструкцию громоздкой. Система группирует связанные операции: несколько вызовов функций внутри одного сервиса объединяются в один шаг "Обработка в CartService".

### Форматы экспорта

Markdown — для интеграции с документацией, README, вики. Изображения встраиваются как base64 или ссылки на файлы.

HTML — для standalone документации. Включает стили, интерактивные элементы (увеличение изображений, разворачивание кода).

PDF — для печати и оффлайн чтения. Генерируется из HTML через weasyprint или wkhtmltopdf.

---

## TODO 5.5: Интерактивные элементы

### Что нужно сделать

Реализовать обработку интерактивных элементов UI: модальные окна, dropdown меню, tooltips, раскрывающиеся секции.

### Проблема с интерактивными элементами

Модальное окно не видно на скриншоте пока не нажата кнопка его открывающая. Dropdown меню показывается только при клике или hover. Для документации этих элементов нужно сначала выполнить действие.

### Анализ кода для определения триггеров

Из кода компонента можно извлечь что вызывает показ элемента. Например, onClick={() => setIsModalOpen(true)} показывает что клик открывает модальное окно.

Система анализирует обработчики событий и состояние компонентов чтобы понять какие действия нужны для показа интерактивных элементов.

### Последовательность действий

Для скриншота модального окна: открыть страницу → найти триггер-элемент → выполнить клик → дождаться появления модального окна → сделать скриншот.

Playwright поддерживает все эти действия: page.click(), page.waitForSelector(), page.screenshot().

### Обработка состояний формы

Формы имеют разные состояния: пустая, заполненная, с ошибками валидации, в процессе отправки, после успешной отправки. Для полной документации может понадобиться скриншот каждого состояния.

Система может программно заполнять формы тестовыми данными и вызывать валидацию для получения нужных состояний.

---

## Рекомендуемые технологии

### Playwright

Библиотека playwright для Python. Установка: pip install playwright && playwright install chromium. Использует Chromium для рендеринга, что обеспечивает совместимость с современными web-приложениями.

### Pillow

Основная библиотека для работы с изображениями. Рисование примитивов, добавление текста, композиция изображений.

### mermaid-cli

Для рендеринга Mermaid-диаграмм. Установка: npm install -g @mermaid-js/mermaid-cli. Вызов: mmdc -i input.mmd -o output.svg.

### Docker

Для изоляции запускаемых приложений. Python docker SDK для управления контейнерами программно.

---

## Рекомендуемые модели ИИ

### Для генерации описаний шагов

Нужна модель с хорошим русским языком и пониманием кода. 

Claude Sonnet/Opus через API — отличное качество, понимание контекста, хороший русский. Дорого для больших объёмов.

deepseek-r1 через OpenRouter — хорошее соотношение цена/качество, бесплатный tier. Уже настроен в проекте.

Qwen-2.5-72B через OpenRouter — сильная модель для длинных текстов, хороший multilingual.

### Для анализа UI и элементов

Если нужно понять что изображено на скриншоте (для верификации):

GPT-4 Vision или Claude с vision — понимают содержимое скриншотов, могут проверить правильность аннотаций.

### Для генерации тестовых данных

Для заполнения форм и мокирования API нужны реалистичные тестовые данные.

LLM может генерировать тестовые данные по описанию модели: "Сгенерируй 5 примеров Product с полями name, price, description для интернет-магазина электроники".

---

## Оценка трудозатрат

TODO 5.1 (Playwright рендеринг): 4-5 дней — настройка, Docker, мокирование API.

TODO 5.2 (Аннотирование): 3-4 дня — рисование, позиционирование, связь с кодом.

TODO 5.3 (Диаграммы): 3-4 дня — генерация разных типов, рендеринг.

TODO 5.4 (Пошаговые инструкции): 4-5 дней — структура, генерация текста, экспорт.

TODO 5.5 (Интерактивные элементы): 3-4 дня — анализ триггеров, последовательности действий.

Общая оценка фазы: 3-4 недели.

---

## Критерии завершения фазы

Система успешно запускает тестовое React-приложение и делает скриншоты. Аннотации корректно позиционируются на скриншотах. Диаграммы генерируются и рендерятся без ошибок. Пошаговые инструкции читаемы и полезны для разработчика. Экспорт работает в Markdown, HTML, PDF.
