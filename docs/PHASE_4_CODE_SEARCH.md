# Фаза 4. Поиск по коду

## Общее описание фазы

Граф знаний построен, теперь нужно научиться эффективно по нему искать. Обычный RAG делает один поиск по embeddings и возвращает топ-N результатов. Для кода этого недостаточно. Когда разработчик спрашивает "как работает оформление заказа", ему нужна вся цепочка: кнопка на фронте, форма, API-вызов, эндпоинт на бэке, сервис, модель данных. Эта фаза реализует multi-hop поиск, который находит начальные точки и расширяет результаты по связям графа.

Результат фазы — система поиска, которая по вопросу пользователя находит все релевантные части кода в обоих репозиториях и возвращает их в логичном порядке с объяснением связей.

---

## TODO 4.1: Расширение retrieval pipeline для кода

### Что нужно сделать

Создать новый retriever, который работает с кодовыми сущностями и использует граф знаний для улучшения результатов.

### Отличия от документного retrieval

Текущий retrieval в проекте оптимизирован для текстовых документов: гибридный поиск (dense + BM25), RRF для объединения результатов, Cross-Encoder для переранжирования. Эти техники применимы и к коду, но с адаптациями.

Для кода важнее точное совпадение имён. Если разработчик ищет "функция calculate_total", он хочет найти именно её, а не семантически похожие функции. Вес BM25 компонента должен быть выше чем для документов.

Для кода важен контекст. Найденную функцию нужно показать вместе с её классом, импортами, связанными функциями. Это отличается от документов, где достаточно показать чанк с небольшим перекрытием.

### Интеграция с существующим pipeline

Новый CodeRetriever реализует тот же интерфейс что и существующий DocumentRetriever. Это позволяет использовать общую инфраструктуру: Query Expansion, Cross-Encoder reranking, RRF. Но конкретные реализации этапов отличаются.

### Типы поиска

Поиск по коду поддерживает разные режимы. Semantic search — поиск по смыслу вопроса, как в документах. Exact match — поиск по точному имени сущности. Structural search — поиск по структуре (все классы наследующие X, все функции с декоратором Y). Graph traversal — расширение результатов по связям.

По умолчанию используется комбинация: сначала semantic + exact match для начальных результатов, затем graph traversal для расширения контекста.

---

## TODO 4.2: Multi-hop поиск по графу

### Что нужно сделать

Реализовать алгоритм, который после нахождения начальных узлов расширяет результаты, проходя по связям графа.

### Концепция multi-hop

Один "hop" — это переход по одной связи графа. Если нашли функцию add_to_cart, один hop по связи CALLS даёт функции которые она вызывает. Один hop по связи HANDLES_REQUEST даёт эндпоинт который она обрабатывает. Multi-hop — это несколько таких переходов.

### Алгоритм расширения

Шаг первый: начальный поиск. Семантический и лексический поиск по запросу пользователя. Результат — множество начальных узлов с relevance scores.

Шаг второй: определение направлений расширения. В зависимости от типа вопроса выбираются связи для обхода. Вопрос "как работает X" требует расширения по CALLS (что вызывает) и SENDS_REQUEST_TO (какой API используется). Вопрос "где используется X" требует обратного обхода — кто вызывает эту функцию.

Шаг третий: расширение по связям. Для каждого начального узла получаем связанные узлы через выбранные типы связей. Связанные узлы добавляются в результаты с уменьшенным score (чем дальше от начального узла, тем ниже релевантность).

Шаг четвёртый: ограничение и ранжирование. Расширение ограничивается по глубине (обычно 2-3 hop) и по количеству узлов. Результаты ранжируются по комбинации: начальный relevance score, расстояние от начального узла, тип связи (некоторые связи важнее других).

### Пример работы

Запрос: "как добавить товар в корзину"

Начальный поиск находит: компонент AddToCartButton.tsx (высокий score по семантике), функцию add_item в CartService (средний score).

Расширение от AddToCartButton: по SENDS_REQUEST_TO находит эндпоинт POST /cart/items. По CONTAINS находит файл AddToCartButton.tsx.

Расширение от POST /cart/items: по HANDLES_REQUEST находит функцию create_cart_item в views. По USES_MODEL находит модели Cart и CartItem.

Расширение от create_cart_item: по CALLS находит CartService.add_item.

Итоговый результат содержит всю цепочку от UI до базы данных, в правильном порядке.

### Настройка глубины

Разные вопросы требуют разной глубины обхода. Простой вопрос "покажи функцию X" не требует расширения. Сложный вопрос "как данные проходят через систему" требует глубокого обхода. Глубина может определяться эвристически по типу вопроса или настраиваться пользователем.

---

## TODO 4.3: Определение scope запроса

### Что нужно сделать

Реализовать классификацию запроса для определения, к какой части системы он относится: фронтенд, бэкенд, или обе части.

### Зачем это нужно

Поиск по всему графу может давать слишком много результатов или нерелевантные результаты. Если разработчик спрашивает "как стилизовать кнопку", ему не нужен код бэкенда. Если спрашивает "как работает валидация модели", не нужен фронтенд.

Определение scope позволяет ограничить поиск нужной частью системы и показать более релевантные результаты.

### Индикаторы scope

Ключевые слова frontend: компонент, кнопка, страница, форма, стили, CSS, React, хук, useState, UI, интерфейс, отображение, рендер.

Ключевые слова backend: эндпоинт, API, модель, база данных, миграция, сервис, контроллер, валидация, авторизация, Django, FastAPI, ORM.

Ключевые слова hybrid (обе части): как работает, поток данных, интеграция, запрос, ответ, полный процесс.

### Классификация

Простой подход: подсчёт ключевых слов каждой категории. Более сложный: использование LLM для классификации вопроса в одну из категорий.

Результат классификации — scope: frontend, backend, hybrid. При поиске scope используется как фильтр: в режиме frontend ищем только в репозиториях с type=frontend, в режиме backend — только в backend.

### Неявный scope

Иногда scope можно определить не по запросу, а по контексту разговора. Если предыдущие вопросы были про фронтенд, следующий вопрос "как это исправить" вероятно тоже про фронтенд.

---

## TODO 4.4: Интеграция существующих RAG-улучшений

### Что нужно сделать

Адаптировать существующие в проекте улучшения (Query Expansion, Cross-Encoder, RRF, Context Window) для работы с кодом.

### Query Expansion для кода

Текущая Query Expansion добавляет синонимы и связанные термины. Для кода нужна специфичная логика. Термин "авторизация" расширяется до "authentication", "login", "jwt", "token", "permission". Термин "список" расширяется до "list", "array", "queryset", "collection".

Также полезно расширять технические термины до их вариантов написания: "e-mail" → "email", "user_id" → "userId", "camelCase" ↔ "snake_case".

### Cross-Encoder для кода

Cross-Encoder оценивает релевантность пары (запрос, документ). Для кода документом является код функции/класса. Текущая модель cross-encoder/mmarco-mMiniLMv2-L12-H384-v1 обучена на текстах, но должна работать и для кода с комментариями.

Если качество недостаточное, можно использовать code-специфичные модели или дообучить существующую на парах (вопрос о коде, код).

### RRF для кода

Reciprocal Rank Fusion объединяет результаты нескольких методов поиска. Для кода объединяем: семантический поиск по embeddings, BM25 по тексту кода, BM25 по именам сущностей. Веса могут отличаться от документов — для кода вес точного совпадения имён должен быть выше.

### Context Window для кода

Текущий Context Window добавляет соседние чанки. Для кода это работает иначе: добавляется не соседний чанк, а связанные сущности из графа. Нашли метод — добавляем сигнатуру класса. Нашли функцию — добавляем импорты файла.

---

## TODO 4.5: Специализированные стратегии поиска

### Что нужно сделать

Реализовать готовые стратегии поиска для типичных задач разработчика.

### Стратегия "UI to Database"

По названию элемента интерфейса или действия пользователя найти всю цепочку до базы данных. Начальная точка: компонент или обработчик событий на фронте. Расширение: API-вызов → эндпоинт → сервис/view → модель → таблица. Результат сортируется в порядке потока данных.

Пример запроса: "что происходит когда пользователь нажимает Оформить заказ"

### Стратегия "Database to UI"

Обратная стратегия: по модели или таблице найти все места где эти данные отображаются. Начальная точка: ModelNode. Расширение: эндпоинты использующие модель → компоненты вызывающие эндпоинты → роуты где рендерятся компоненты. Результат показывает все UI-представления данных.

Пример запроса: "где отображается информация о заказе"

### Стратегия "Impact Analysis"

По функции или компоненту найти все места, которые будут затронуты при его изменении. Обратный обход графа: кто вызывает эту функцию, кто использует этот компонент, какие тесты это покрывают. Полезно перед рефакторингом.

Пример запроса: "что сломается если изменить функцию calculate_discount"

### Стратегия "Implementation Guide"

По описанию задачи найти все места, которые нужно изменить для реализации. Комбинация поиска похожих реализаций (как это сделано для аналогичной фичи) и анализа архитектуры (какие слои нужно затронуть).

Пример запроса: "как добавить новое поле в форму регистрации"

### Стратегия "Pattern Search"

Найти все сущности, соответствующие паттерну. Все эндпоинты требующие авторизации. Все компоненты использующие определённый хук. Все модели с полем created_at. Это структурный поиск по атрибутам и связям, без семантики.

Пример запроса: "все эндпоинты которые требуют аутентификации"

---

## TODO 4.6: Фильтрация и ранжирование результатов

### Что нужно сделать

Реализовать механизмы фильтрации результатов по различным критериям и финальное ранжирование для отображения пользователю.

### Фильтры

Фильтр по репозиторию: искать только в frontend, только в backend, или в обоих.

Фильтр по типу сущности: только функции, только компоненты, только эндпоинты.

Фильтр по файлу/директории: искать только в src/services/, исключить tests/.

Фильтр по метаданным: только public функции, только экспортируемые компоненты, только модели определённого типа.

### Ранжирование

Финальное ранжирование учитывает несколько факторов:

Relevance score — насколько результат соответствует запросу. Комбинация semantic similarity, BM25 score, Cross-Encoder score.

Distance from initial — сколько hops от начальных результатов. Чем дальше, тем ниже ранг, но всё ещё полезно для контекста.

Entity importance — некоторые сущности важнее других. Публичные API важнее внутренних функций. Главные компоненты страниц важнее мелких утилит. Это можно определять по количеству связей (более используемое = более важное).

Recency — недавно изменённые файлы могут быть более релевантны для вопросов о текущем состоянии кода.

### Группировка результатов

Результаты группируются логически. Все сущности из одного файла показываются вместе. Связанные цепочки (компонент → API → эндпоинт) показываются как единое целое. Это улучшает читаемость.

---

## Рекомендуемые модели ИИ

### Embedding модели

Для семантического поиска по коду лучше всего работают модели, обученные на коде и тексте вместе.

BAAI/bge-m3 — текущий выбор в проекте. Хорошо работает для мультиязычного контента. Размер 567M параметров, достаточно быстрая.

Альтернативы для экспериментов:

voyage-code-2 от Voyage AI — специализированная модель для кода, показывает отличные результаты на code retrieval benchmarks. Доступна через API.

CodeSage от Microsoft — open source модель для code embeddings. Доступна на HuggingFace.

jina-embeddings-v3 — мультиязычная модель с хорошей поддержкой кода.

### Cross-Encoder для reranking

Текущий cross-encoder/mmarco-mMiniLMv2-L12-H384-v1 подходит для начала. Для улучшения качества на коде можно рассмотреть:

Cohere Rerank — API сервис с высоким качеством, поддерживает код.

bge-reranker-v2-m3 — open source reranker от BAAI, совместим с bge-m3 embeddings.

### LLM для классификации запросов

Для определения scope и типа запроса не нужна мощная модель. Достаточно быстрой модели с хорошим следованием инструкциям.

deepseek-r1 через OpenRouter — уже настроен в проекте, бесплатный, достаточно хорош для классификации.

Qwen3-8B локально — если нужна локальная модель для приватности или скорости.

---

## Оценка трудозатрат

TODO 4.1 (Code Retriever): 3-4 дня — новый retriever, интеграция с существующим.

TODO 4.2 (Multi-hop): 4-5 дней — сложный алгоритм обхода графа.

TODO 4.3 (Scope detection): 2-3 дня — классификация запросов.

TODO 4.4 (Интеграция RAG улучшений): 2-3 дня — адаптация существующего кода.

TODO 4.5 (Стратегии поиска): 4-5 дней — несколько специализированных стратегий.

TODO 4.6 (Фильтрация и ранжирование): 2-3 дня — фильтры, ранжирование, группировка.

Общая оценка фазы: 3-4 недели.

---

## Критерии завершения фазы

Multi-hop поиск находит связанные сущности из обоих репозиториев. Поиск "как работает X" возвращает полную цепочку от UI до базы данных. Определение scope работает корректно для типичных запросов. Время поиска приемлемое (менее 5 секунд для типичного запроса). Результаты ранжированы разумно — наиболее релевантные вверху.
