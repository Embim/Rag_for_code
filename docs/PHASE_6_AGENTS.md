# Фаза 6. Агенты и оркестрация

## Общее описание фазы

Предыдущие фазы создали компоненты: парсеры, граф знаний, поиск, визуализация. Эта фаза связывает их вместе через LLM-агентов, которые могут итеративно исследовать код, принимать решения о том какие инструменты использовать, и создавать комплексные ответы. Агентный подход позволяет обрабатывать сложные вопросы, которые невозможно решить одним запросом к поиску.

Результат фазы — интеллектуальные агенты, которые понимают вопрос пользователя, планируют исследование кода, используют нужные инструменты, и формируют информативный ответ с кодом и визуализациями.

---

## TODO 6.1: Агент исследования кода (Code Explorer)

### Что нужно сделать

Создать LLM-агента, который итеративно исследует кодовую базу для ответа на вопрос. Агент имеет набор инструментов и сам решает какие из них использовать.

### Концепция агента

Агент — это LLM, который работает в цикле: получает задачу → планирует действия → выполняет инструменты → анализирует результаты → решает нужно ли продолжать → формирует ответ. В отличие от простого RAG, агент может делать несколько итераций и адаптировать стратегию на основе промежуточных результатов.

### Инструменты агента

semantic_search(query, scope) — семантический поиск по графу знаний. Возвращает релевантные сущности с кодом.

exact_search(name, entity_type) — поиск по точному имени. Найти функцию "calculate_total" или класс "CartService".

get_entity_details(entity_id) — получить полную информацию о сущности: код, docstring, связи, файл.

get_related_entities(entity_id, relation_type) — получить связанные сущности. Например, все функции которые вызывает данная функция.

list_files(directory) — список файлов в директории. Для понимания структуры проекта.

read_file(path, start_line, end_line) — прочитать фрагмент файла. Для получения контекста вокруг сущности.

grep(pattern, scope) — поиск по регулярному выражению. Для нахождения использований переменной или паттерна.

get_graph_path(from_entity, to_entity) — найти путь между сущностями в графе. Для понимания как они связаны.

### Цикл работы агента

Инициализация: агент получает вопрос пользователя и контекст (какие репозитории загружены, какой scope).

Планирование: LLM анализирует вопрос и формирует план исследования. Для вопроса "как работает оформление заказа" план может быть: найти компоненты связанные с заказом, проследить API-вызовы, найти backend обработчики.

Выполнение: агент последовательно вызывает инструменты согласно плану. После каждого вызова анализирует результат и может скорректировать план.

Синтез: когда собрано достаточно информации, агент формирует итоговый ответ. Ответ включает объяснение, ссылки на код, порядок вызовов.

### Ограничения

Агент ограничен по количеству итераций (например, 10) и по использованию токенов. Это предотвращает бесконечные циклы на сложных вопросах. Если лимит достигнут, агент возвращает лучший ответ который смог сформировать с пометкой о неполноте.

### Память агента

В рамках одной сессии агент помнит что уже нашёл. Это предотвращает повторные поиски одного и того же. Память очищается между сессиями, но можно реализовать долгосрочную память для часто задаваемых вопросов.

---

## TODO 6.2: Агент визуальных инструкций (Visual Guide Agent)

### Что нужно сделать

Создать специализированного агента для создания визуальных пошаговых инструкций. Этот агент дополняет Code Explorer возможностями визуализации.

### Инструменты агента

take_screenshot(url, selector_to_highlight) — сделать скриншот страницы с выделением элемента.

annotate_screenshot(screenshot_id, annotations) — добавить аннотации на скриншот: стрелки, обводки, подписи.

click_element(selector) — выполнить клик для показа интерактивного элемента.

fill_form(fields) — заполнить форму тестовыми данными.

generate_diagram(diagram_type, entities) — сгенерировать диаграмму (sequence, flowchart, ER).

create_step(title, description, visual_content) — создать шаг инструкции.

compile_guide(steps, format) — собрать шаги в документ.

### Workflow агента

Анализ задачи: агент определяет какой тип визуализации нужен. Вопрос "покажи как добавить товар" требует скриншотов UI. Вопрос "объясни архитектуру модуля" требует диаграммы.

Планирование визуализации: агент определяет какие скриншоты нужны, в каком порядке, какие элементы выделить.

Создание контента: последовательно создаются скриншоты, добавляются аннотации, генерируются диаграммы.

Сборка документа: шаги компилируются в итоговый документ с правильной структурой.

### Интеграция с Code Explorer

Visual Guide Agent может вызывать Code Explorer для получения информации о коде. Обратно, Code Explorer может вызывать Visual Guide Agent когда понимает что вопрос требует визуализации.

Или оба агента работают параллельно под управлением оркестратора.

---

## TODO 6.3: Оркестратор

### Что нужно сделать

Создать компонент, который координирует работу всех агентов и компонентов системы, определяет какой подход использовать для конкретного вопроса.

### Классификация входящих вопросов

Оркестратор первым делом классифицирует вопрос:

Document question — вопрос по текстовым документам (банковская документация). Направляется в существующий RAG pipeline.

Code question — вопрос по коду, не требующий визуализации. Направляется в Code Explorer.

Visual question — вопрос требующий визуализации UI. Направляется в Visual Guide Agent.

Hybrid question — сложный вопрос, требующий комбинации подходов.

### Критерии классификации

Document indicators: упоминание документов, регламентов, инструкций, банковских терминов; вопросы о правилах и процедурах.

Code indicators: упоминание кода, функций, компонентов, API; вопросы типа "как реализовано", "где находится".

Visual indicators: упоминание UI, экрана, кнопки, формы; вопросы типа "покажи", "как выглядит", "где нажать".

### Маршрутизация

После классификации оркестратор создаёт нужного агента (или несколько) и передаёт им вопрос. Для hybrid questions агенты могут работать последовательно (сначала найти код, потом визуализировать) или параллельно.

### Агрегация результатов

Если работали несколько агентов, их результаты объединяются. Например, Code Explorer нашёл реализацию, Visual Guide Agent сделал скриншоты — итоговый ответ содержит и то и другое.

### Streaming

Для лучшего UX оркестратор поддерживает streaming результатов. Пользователь видит промежуточный прогресс: "Ищу компоненты...", "Нашёл CartButton, исследую API-вызовы...", "Создаю скриншот страницы...".

---

## TODO 6.4: Кэширование результатов

### Что нужно сделать

Реализовать кэширование на нескольких уровнях для ускорения повторных запросов.

### Уровни кэширования

Query cache — если точно такой же вопрос уже задавали, вернуть готовый ответ. Инвалидация: при обновлении индекса кода.

Semantic cache — если похожий вопрос уже задавали (high cosine similarity), использовать кэшированный ответ как основу. Агент может дополнить или адаптировать его.

Tool result cache — результаты вызовов инструментов (особенно дорогих, как скриншоты) кэшируются. Повторный запрос скриншота той же страницы возвращает кэш.

LLM response cache — для одинаковых промптов можно использовать кэшированные ответы LLM.

### Хранение кэша

Redis подходит для всех типов кэша. TTL устанавливается в зависимости от типа: query cache — 24 часа, tool results — 1 час, LLM responses — по контенту промпта.

Для semantic cache нужно хранить embeddings вопросов и искать ближайших соседей. Можно использовать Weaviate для этого.

### Инвалидация

При изменении кода репозитория (push, reindex) инвалидируются связанные записи кэша. Нужно отслеживать зависимости: какие ответы зависят от каких файлов.

---

## TODO 6.5: Обработка ошибок и fallbacks

### Что нужно сделать

Реализовать graceful degradation когда что-то идёт не так: агент не может найти информацию, инструмент падает с ошибкой, истекает timeout.

### Типы ошибок

Не найдено: агент искал, но не нашёл релевантную информацию. Ответ пользователю: "Не удалось найти информацию о X. Возможно, попробуйте переформулировать вопрос или уточнить scope."

Timeout: агент работает слишком долго. Ответ: лучший результат на текущий момент с пометкой что исследование не завершено.

Tool failure: инструмент (например, Playwright для скриншотов) падает с ошибкой. Fallback: продолжить без этого инструмента, в ответе указать что визуализация недоступна.

LLM error: ошибка API или превышение rate limit. Fallback: retry с exponential backoff, или использовать fallback модель.

### Логирование для отладки

Все ошибки логируются с полным контекстом: какой вопрос, какой агент, какой инструмент, какая ошибка. Это помогает диагностировать проблемы.

### User feedback

После каждого ответа пользователь может дать feedback (полезно / не полезно). Негативный feedback логируется вместе с контекстом для анализа и улучшения системы.

---

## Рекомендуемые технологии

### LangChain или LlamaIndex

Фреймворки для построения LLM-приложений с агентами. Предоставляют абстракции для инструментов, памяти, цепочек вызовов.

LangChain более гибкий, больше интеграций. LlamaIndex лучше для RAG-специфичных задач.

Можно использовать для ускорения разработки, или реализовать агентов вручную для полного контроля.

### Redis

Для кэширования. redis-py клиент для Python. Поддерживает TTL, atomic операции, pub/sub для уведомлений.

### Asyncio

Для параллельного выполнения инструментов и асинхронных вызовов LLM API. Улучшает latency для сложных запросов.

---

## Рекомендуемые модели ИИ

### Для агентов

Агенты требуют модели с хорошим следованием инструкциям и способностью к рассуждениям.

Claude Sonnet 4 — отличное качество рассуждений, хорошо работает с инструментами (function calling). Рекомендуется для production.

GPT-4o — альтернатива с хорошей поддержкой function calling и длинного контекста.

deepseek-r1 — для экономии бюджета. Качество ниже, но приемлемое для многих задач.

Qwen-2.5-72B — хороший баланс качества и стоимости, сильный в рассуждениях.

### Для классификации

Классификация вопросов — простая задача, не требует мощной модели.

deepseek-r1 — достаточно для классификации, бесплатный tier.

Можно обучить маленький классификатор (BERT-based) на примерах если объём запросов большой.

### Для генерации текстов

Описания в пошаговых инструкциях требуют хорошего русского языка.

Claude — лучший русский язык среди LLM.

GigaChat — русскоязычная модель от Сбера, если нужна модель без зависимости от западных сервисов.

---

## Оценка трудозатрат

TODO 6.1 (Code Explorer): 5-6 дней — архитектура агента, инструменты, цикл.

TODO 6.2 (Visual Guide Agent): 4-5 дней — специфичные инструменты, интеграция с визуализацией.

TODO 6.3 (Оркестратор): 3-4 дня — классификация, маршрутизация, агрегация.

TODO 6.4 (Кэширование): 2-3 дня — Redis интеграция, политики инвалидации.

TODO 6.5 (Обработка ошибок): 2-3 дня — fallbacks, логирование, feedback.

Общая оценка фазы: 3-4 недели.

---

## Критерии завершения фазы

Агенты успешно отвечают на тестовые вопросы разных типов. Оркестратор правильно классифицирует вопросы и направляет их нужным агентам. Кэширование работает и ускоряет повторные запросы. Ошибки обрабатываются gracefully, пользователь получает понятные сообщения. Streaming работает — пользователь видит прогресс.
