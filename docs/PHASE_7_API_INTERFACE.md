# Фаза 7. API и интерфейс

## Общее описание фазы

Все компоненты системы готовы, теперь нужно сделать их доступными для использования. Эта фаза создаёт REST API для интеграции с другими системами и веб-интерфейс для прямого использования. API позволит встроить Code RAG в IDE, CI/CD pipeline, или корпоративный портал. Веб-интерфейс даст возможность использовать систему без программирования.

Результат фазы — полноценное приложение с API и UI, готовое к использованию командой разработки.

---

## TODO 7.1: REST API на FastAPI

### Что нужно сделать

Создать REST API, который предоставляет все возможности системы: управление репозиториями, поиск, визуализация.

### Почему FastAPI

FastAPI уже используется частично в проекте, это современный асинхронный фреймворк с автоматической генерацией OpenAPI документации, отличной поддержкой типизации через Pydantic, и высокой производительностью.

### Структура API

Группа /repos — управление репозиториями:

POST /repos — добавить репозиторий. Принимает URL, тип, название. Возвращает ID репозитория и статус.

GET /repos — список всех репозиториев с их статусами индексации.

GET /repos/{repo_id} — детали репозитория: статистика по сущностям, дата последней индексации, ошибки.

DELETE /repos/{repo_id} — удалить репозиторий и его индекс.

POST /repos/{repo_id}/reindex — запустить переиндексацию.

Группа /search — поиск:

POST /search — основной эндпоинт поиска. Принимает query, scope (documents/code/all), filters. Возвращает результаты с кодом и метаданными.

POST /search/graph — поиск с расширением по графу. Дополнительно возвращает связанные сущности.

Группа /query — агентные запросы:

POST /query — отправить вопрос агенту. Возвращает ответ с объяснением, кодом, ссылками.

GET /query/{query_id}/stream — Server-Sent Events для streaming ответа агента.

Группа /visualize — визуализация:

POST /visualize/screenshot — сделать скриншот страницы с аннотациями.

POST /visualize/diagram — сгенерировать диаграмму по указанным сущностям.

POST /visualize/guide — создать пошаговую инструкцию.

Группа /entities — прямой доступ к сущностям:

GET /entities/{entity_id} — получить сущность по ID.

GET /entities/{entity_id}/code — получить исходный код сущности.

GET /entities/{entity_id}/related — получить связанные сущности.

### Pydantic схемы

Все request и response body типизированы через Pydantic. Это обеспечивает валидацию, автодокументацию, и удобство использования.

Примеры схем:

```
class RepoCreate:
    url: str
    name: str
    type: Literal["frontend", "backend"]
    framework: Optional[str]

class SearchRequest:
    query: str
    scope: Literal["documents", "code", "all"] = "all"
    filters: Optional[SearchFilters]
    limit: int = 10

class SearchResult:
    entities: List[EntitySummary]
    total: int
    search_time_ms: int
```

### Асинхронность

Все эндпоинты асинхронные (async def). Это важно для:

Параллельной обработки нескольких запросов.

Эффективной работы с базой данных и внешними API.

Streaming ответов агентов.

### Middleware

Логирование запросов — каждый запрос логируется с timing, параметрами, результатом.

CORS — настраивается для работы с фронтендом на другом домене.

Error handling — все исключения преобразуются в структурированные JSON-ошибки.

Request ID — каждый запрос получает уникальный ID для трассировки.

---

## TODO 7.2: Аутентификация и авторизация

### Что нужно сделать

Реализовать защиту API от неавторизованного доступа.

### Варианты аутентификации

API Key — простейший вариант для внутреннего использования. Ключ передаётся в заголовке X-API-Key или Authorization.

OAuth 2.0 / JWT — для интеграции с корпоративными системами. Поддержка SSO через Google, GitHub, или корпоративный IdP.

Для начала достаточно API Key, OAuth добавляется при необходимости.

### Управление ключами

API ключи генерируются через отдельный эндпоинт или CLI. Каждый ключ имеет: имя (для идентификации), scopes (какие операции разрешены), rate limits, дату создания и истечения.

### Rate Limiting

Защита от злоупотреблений через ограничение количества запросов. Используется sliding window алгоритм. Лимиты настраиваются по эндпоинтам и по API ключам.

Хранение счётчиков — в Redis для распределённой работы.

### Логирование аудита

Все операции изменения (создание репозиториев, переиндексация, удаление) логируются с информацией о том кто и когда их выполнил.

---

## TODO 7.3: WebSocket для streaming

### Что нужно сделать

Реализовать WebSocket эндпоинт для real-time streaming ответов агентов.

### Зачем WebSocket

Агенты работают итеративно, каждый шаг занимает время. Без streaming пользователь ждёт весь ответ целиком, что может быть десятки секунд. Со streaming пользователь видит прогресс: какие инструменты вызываются, какие промежуточные результаты.

### Протокол

Соединение устанавливается на /ws/query. После установки клиент отправляет JSON с вопросом:

```
{"type": "query", "text": "как работает корзина", "scope": "code"}
```

Сервер отправляет серию сообщений:

```
{"type": "status", "message": "Анализирую вопрос..."}
{"type": "status", "message": "Ищу компоненты..."}
{"type": "partial", "content": "Нашёл CartButton.tsx"}
{"type": "status", "message": "Исследую API-вызовы..."}
{"type": "result", "content": "...полный ответ..."}
```

### Heartbeat

Для поддержания соединения сервер периодически отправляет ping, клиент отвечает pong. Если ответа нет — соединение закрывается.

### Переподключение

Клиент должен уметь переподключаться при разрыве соединения и продолжать с того места где остановился (если запрос ещё обрабатывается).

---

## TODO 7.4: Веб-интерфейс на Streamlit

### Что нужно сделать

Создать веб-приложение для использования системы без программирования.

### Почему Streamlit

Streamlit позволяет быстро создавать data-ориентированные веб-приложения на Python. Не требует знания JavaScript/React. Встроенная поддержка чатов, визуализации, загрузки файлов.

Альтернатива — Gradio, но Streamlit более гибкий для сложных интерфейсов.

### Страницы приложения

Главная страница — чат с системой. Поле ввода вопроса, история диалога, отображение ответов с кодом и визуализациями.

Репозитории — управление подключёнными репозиториями. Форма добавления, список с статусами, кнопки переиндексации и удаления.

Граф знаний — визуализация структуры кода. Интерактивная диаграмма связей между сущностями. Клик на узел показывает детали.

Настройки — конфигурация системы. API ключи, профили поиска, настройки LLM.

### Компоненты интерфейса

Chat input — поле ввода с кнопкой отправки, поддержка Enter для отправки.

Message display — отображение сообщений с форматированием Markdown, подсветкой кода, встроенными изображениями.

Code viewer — блок с кодом, подсветка синтаксиса, возможность копирования, ссылка на файл.

Image viewer — отображение скриншотов с возможностью увеличения.

Diagram viewer — рендеринг Mermaid диаграмм.

Progress indicator — показ прогресса при длительных операциях.

### Session state

Streamlit перезапускает скрипт при каждом взаимодействии. Состояние сохраняется в st.session_state: история чата, выбранный репозиторий, настройки пользователя.

### Стилизация

Streamlit позволяет кастомизировать стили через CSS. Создать тему, соответствующую брендингу компании или проекта.

---

## TODO 7.5: Интеграция с IDE

### Что нужно сделать

Создать плагин или расширение для интеграции Code RAG с популярными IDE.

### VS Code Extension

VS Code — самый популярный редактор. Расширение добавляет:

Боковую панель для чата с системой. Вопросы отправляются на API, ответы отображаются в панели.

Команду "Ask Code RAG" для отправки выделенного кода или текущего файла как контекста к вопросу.

Code lens (подсказки над функциями) с информацией о связях: кто вызывает, где используется.

Hover информацию: при наведении на функцию показывает связанные эндпоинты или компоненты.

### JetBrains Plugin

PyCharm, WebStorm и другие IDE от JetBrains. Аналогичная функциональность через Plugin API JetBrains.

### Приоритет

VS Code extension как первый шаг — наибольший охват пользователей. JetBrains plugin как второй шаг для команд использующих эти IDE.

### Технологии

VS Code extensions пишутся на TypeScript. Используют API расширений VS Code и обращаются к нашему REST API.

---

## TODO 7.6: CLI улучшения

### Что нужно сделать

Улучшить существующий CLI для удобной работы с системой из терминала.

### Текущее состояние

В проекте есть main_pipeline.py с командами build, search, evaluate. Это базовый функционал.

### Новые команды

repo add <url> --name <name> --type <type> — добавить репозиторий.

repo list — показать все репозитории.

repo reindex <name> — переиндексировать репозиторий.

ask "<question>" — задать вопрос и получить ответ.

ask --interactive — интерактивный режим с историей.

visualize <entity_id> — создать визуализацию для сущности.

### Rich formatting

Использовать библиотеку Rich для красивого вывода в терминале: подсветка синтаксиса для кода, таблицы для результатов, прогресс-бары для длительных операций, Markdown рендеринг.

### Shell completion

Автодополнение команд и аргументов для bash, zsh, fish. Реализуется через click или typer.

---

## Рекомендуемые технологии

### FastAPI

Основной фреймворк для API. С pydantic для схем, uvicorn как ASGI сервер.

### Streamlit

Для веб-интерфейса. Версия 1.30+ для лучшей поддержки чатов.

### Rich

Для красивого CLI вывода. Интегрируется с typer/click.

### Typer

Для построения CLI. Обёртка над Click с лучшей типизацией.

### WebSocket

FastAPI имеет встроенную поддержку WebSocket через starlette.

---

## Модели ИИ для этой фазы

В этой фазе модели ИИ не используются напрямую — это инфраструктурная фаза. API просто передаёт запросы агентам из фазы 6.

---

## Оценка трудозатрат

TODO 7.1 (REST API): 4-5 дней — эндпоинты, схемы, middleware.

TODO 7.2 (Аутентификация): 2-3 дня — API keys, rate limiting.

TODO 7.3 (WebSocket): 2-3 дня — streaming, протокол.

TODO 7.4 (Streamlit UI): 5-6 дней — страницы, компоненты, стилизация.

TODO 7.5 (IDE интеграция): 5-7 дней — VS Code extension.

TODO 7.6 (CLI улучшения): 2-3 дня — команды, Rich форматирование.

Общая оценка фазы: 3-4 недели.

---

## Критерии завершения фазы

API документация доступна и полна. Все эндпоинты работают и покрыты тестами. Веб-интерфейс функционален и удобен для использования. Streaming работает через WebSocket. Аутентификация защищает API от неавторизованного доступа.
