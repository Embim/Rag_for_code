# Фаза 3. Построение графа знаний

## Общее описание фазы

Парсеры из предыдущей фазы извлекают сущности из отдельных файлов, но не понимают связей между ними. Функция в одном файле вызывает функцию из другого, компонент на фронтенде делает запрос к эндпоинту на бэкенде, модель связана с другой моделью через ForeignKey. Эта фаза строит граф знаний, который представляет все эти связи явно и позволяет по ним навигировать.

Результат фазы — граф, где узлами являются кодовые сущности (функции, классы, компоненты, эндпоинты), а рёбрами — отношения между ними (вызывает, импортирует, обрабатывает запрос). Граф сохраняется в Weaviate и готов для поиска.

---

## TODO 3.1: Структура графа и типы узлов

### Что нужно сделать

Определить формальную структуру графа знаний: какие типы узлов существуют, какие атрибуты у каждого типа, какие типы связей возможны между узлами.

### Типы узлов

FileNode представляет файл с кодом. Атрибуты: путь относительно корня репозитория, язык программирования, размер в байтах, хэш содержимого для отслеживания изменений, ссылка на репозиторий.

FunctionNode представляет функцию или метод. Атрибуты: имя, полная сигнатура с параметрами и типами, docstring если есть, тело функции как текст, номера строк начала и конца, является ли методом класса, декораторы.

ClassNode представляет класс. Атрибуты: имя, список базовых классов (для отслеживания наследования), docstring, декораторы. Методы класса — отдельные FunctionNode со ссылкой на класс.

ComponentNode представляет React-компонент. Атрибуты: имя, props с типами, список используемых хуков, является ли экспортируемым по умолчанию.

EndpointNode представляет API-эндпоинт. Атрибуты: полный путь URL, HTTP-метод, параметры пути и query, ссылка на модель тела запроса, ссылка на модель ответа, ссылка на функцию-обработчик.

ModelNode представляет модель данных (Django Model, Pydantic Model). Атрибуты: имя, тип модели (django, pydantic, sqlalchemy), список полей с их типами и параметрами.

RouteNode представляет маршрут фронтенда. Атрибуты: путь URL, ссылка на компонент который рендерится.

### Иерархия узлов

Узлы образуют иерархию принадлежности. FunctionNode принадлежит FileNode или ClassNode. ClassNode принадлежит FileNode. FileNode принадлежит RepositoryNode. Эта иерархия важна для контекста — показывая функцию, нужно знать в каком файле и классе она находится.

### Атрибуты для поиска

Каждый узел имеет текстовое представление для создания embedding. Для функции это комбинация имени, docstring и тела. Для класса — имя, docstring и имена методов. Это текстовое представление используется для семантического поиска.

Каждый узел также имеет набор ключевых слов для BM25 поиска: имя сущности, имена параметров, имена используемых типов. Это улучшает поиск по точным именам.

---

## TODO 3.2: Типы связей

### Что нужно сделать

Определить все типы связей между узлами графа и правила их создания.

### IMPORTS

Связь от FileNode к FileNode или от FileNode к конкретной сущности. Создаётся на основе import statements в коде. В Python это import module и from module import entity. В TypeScript это import { entity } from "module".

Для imports важно разрешать относительные пути и алиасы. import ./utils означает файл в той же директории. @/components/Button может быть алиасом, настроенным в tsconfig.json.

### CALLS

Связь от FunctionNode к FunctionNode. Создаётся когда одна функция вызывает другую. Определяется анализом AST тела функции: ищутся все вызовы (Call nodes в AST) и сопоставляются с известными функциями.

Сложность в разрешении имён. Вызов calculate() может относиться к локальной функции, импортированной функции, методу объекта. Нужно анализировать область видимости и импорты.

### INHERITS

Связь от ClassNode к ClassNode. Создаётся на основе списка базовых классов. class Dog(Animal) создаёт связь Dog → Animal.

### CONTAINS

Связь принадлежности. FileNode CONTAINS FunctionNode/ClassNode. ClassNode CONTAINS FunctionNode (методы). RepositoryNode CONTAINS FileNode. Это структурная связь для навигации по иерархии.

### HANDLES_REQUEST

Связь от EndpointNode к FunctionNode. Показывает какая функция обрабатывает какой эндпоинт. Создаётся при парсинге декораторов FastAPI или маппинга в Django urls.py.

### SENDS_REQUEST_TO

Связь от ComponentNode (или FunctionNode на фронтенде) к EndpointNode. Это ключевая связь между фронтом и бэком. Создаётся при парсинге API-вызовов на фронтенде и сопоставлении URL с эндпоинтами бэкенда.

### USES_MODEL

Связь от EndpointNode или FunctionNode к ModelNode. Показывает какие модели данных использует эндпоинт для запроса/ответа или какие модели использует функция в своей логике.

### RENDERS_AT

Связь от ComponentNode к RouteNode. Показывает на каком URL рендерится компонент. Важно для визуализации.

### FOREIGN_KEY / MANY_TO_MANY

Связи между ModelNode для Django-моделей. Отражают структуру базы данных и позволяют строить ER-диаграммы.

---

## TODO 3.3: Связывание фронтенда и бэкенда

### Что нужно сделать

Реализовать алгоритм сопоставления API-вызовов на фронтенде с эндпоинтами на бэкенде для создания связей SENDS_REQUEST_TO.

### Почему это сложно

URL на фронтенде и бэкенде записываются по-разному. Фронтенд: /api/products/${id}, /api/products/:id, ${API_URL}/products/${id}. Бэкенд Django: /api/products/<int:pk>/, path("products/<int:pk>/"). Бэкенд FastAPI: /api/products/{product_id}.

Нужно нормализовать все эти форматы к единому представлению для сопоставления.

### Алгоритм нормализации

Шаг первый: убрать base URL. На фронтенде API_URL может быть http://localhost:8000/api или /api. На бэкенде путь начинается от корня приложения. Нужно вычислить общий prefix и работать с относительными путями.

Шаг второй: нормализовать параметры пути. Все варианты переменных частей пути (${id}, :id, <int:pk>, {product_id}) заменяются на единый placeholder {param}. Путь /products/${id}/reviews становится /products/{param}/reviews.

Шаг третий: нормализовать trailing slashes. Django любит слэши в конце, фронтенд обычно без них. Убрать все trailing slashes для сравнения.

### Сопоставление с учётом метода

Один путь может обрабатывать разные HTTP-методы разными функциями. GET /products/ возвращает список, POST /products/ создаёт новый продукт. При сопоставлении нужно учитывать и путь, и метод.

### Обработка неточных совпадений

Не всегда URL совпадают точно. Фронтенд может использовать /api/v1/products/, а бэкенд /products/. Система должна пытаться найти совпадение по части пути если точное не найдено.

Эвристики: если на фронте /api/v1/products и на бэке /products, и это единственный эндпоинт со словом products — вероятно это совпадение. Присваивается confidence score, низкий confidence логируется для ручной проверки.

### Подтверждение через типы

Если на фронте отправляется объект {name: string, price: number}, и Pydantic-модель эндпоинта имеет поля name: str, price: float — это подтверждает правильность связи. Совпадение типов повышает confidence score.

### Хранение связей

Каждая связь SENDS_REQUEST_TO хранит: ссылку на узел-источник (компонент/функция на фронте), ссылку на узел-цель (эндпоинт на бэке), confidence score, метаданные о том как было найдено совпадение (для отладки).

---

## TODO 3.4: Построение графа из результатов парсинга

### Что нужно сделать

Реализовать процесс, который берёт результаты работы парсеров и строит граф: создаёт узлы для всех сущностей, затем проходит вторым проходом и создаёт связи.

### Двухпроходный алгоритм

Первый проход: создание узлов. Для каждого файла каждого репозитория запускается соответствующий парсер. Результаты парсинга преобразуются в узлы графа и сохраняются в Weaviate. На этом этапе связи не создаются, потому что целевые узлы могут ещё не существовать.

Второй проход: создание связей. Для каждого узла анализируются его зависимости (импорты, вызовы, наследование) и создаются соответствующие связи. К этому моменту все узлы существуют и на них можно ссылаться.

### Разрешение имён

Ключевая сложность второго прохода — разрешение имён. Когда функция вызывает calculate(), нужно найти какой именно FunctionNode это. Алгоритм: сначала искать в текущем файле, затем в импортах файла, затем в builtins языка.

Для cross-file зависимостей нужен индекс: по имени модуля найти FileNode, по имени сущности в модуле найти конкретный узел.

### Обработка внешних зависимостей

Не все импорты относятся к коду репозитория. import numpy или from django.db import models — это внешние зависимости. Для них узлы не создаются (код недоступен), но сам факт использования сохраняется в метаданных узла. Это полезно для поиска: найти все места где используется pandas.

### Инкрементальное обновление

При изменении файла нужно обновить только связанные узлы. Алгоритм: удалить старые узлы изменённого файла, создать новые, обновить связи. Сложность: связи из других файлов на удалённые узлы становятся битыми. Нужно или обновить все файлы, которые ссылались на изменённый, или пометить связи как potentially_stale.

---

## TODO 3.5: Индексация графа в Weaviate

### Что нужно сделать

Сохранить граф в Weaviate так, чтобы по нему можно было эффективно искать: и семантически по embeddings, и структурно по связям.

### Создание embeddings

Каждый узел получает vector embedding. Embedding создаётся из текстового представления узла. Для функции: f"Function {name} in {file_path}: {docstring or ''}\n{body}". Для компонента: f"React component {name} with props {props}: {description}".

Модель для embeddings: BAAI/bge-m3 уже используется в проекте и хорошо работает для русского и английского текста, включая код. Альтернатива для кода: CodeBERT или StarCoder embeddings, но они могут быть хуже для смешанного кода с комментариями на русском.

### BM25 индексация

Параллельно с векторами создаётся BM25 индекс по именам сущностей. Для кода лексический поиск важен — разработчики часто ищут по точному имени функции или класса. Weaviate поддерживает hybrid search из коробки.

### Cross-references в Weaviate

Связи графа хранятся как cross-references между объектами. При создании объекта FunctionNode указывается reference на FileNode и опционально на ClassNode. При создании связи CALLS создаётся reference от одного FunctionNode к другому.

Weaviate позволяет делать GraphQL запросы по связям: найти функцию и получить все функции которые она вызывает, или все функции которые вызывают её.

### Оптимизация для поиска

Для ускорения типичных запросов создаются дополнительные индексы. Индекс по имени сущности для быстрого lookup по точному имени. Индекс по типу узла для фильтрации (показать только эндпоинты). Индекс по репозиторию для ограничения поиска одним репозиторием.

### Batch операции

Индексация большого репозитория создаёт тысячи узлов. Weaviate поддерживает batch insert, который значительно быстрее поштучной вставки. Использовать batches по 100-500 объектов.

---

## Рекомендуемые технологии

### NetworkX

Библиотека для работы с графами в Python. Использовать для построения графа в памяти перед сохранением в Weaviate. Удобна для анализа графа: поиск циклов, вычисление метрик, обход связей.

### Weaviate Python Client

Официальный клиент для работы с Weaviate. Поддерживает создание схемы, batch insert, GraphQL запросы, vector search.

---

## Модели ИИ для этой фазы

### Embedding модель

BAAI/bge-m3 — основная модель для создания embeddings. Поддерживает до 8192 токенов контекста, что достаточно для большинства функций. Мультиязычная, хорошо работает с русскими комментариями в коде.

Альтернатива: если качество поиска по коду недостаточное, попробовать специализированные code embeddings. Microsoft CodeBERT, Salesforce CodeT5, или embeddings от StarCoder. Они обучены на коде и могут лучше понимать семантику программ.

### LLM для улучшения связей

В сложных случаях, когда автоматическое сопоставление фронт-бэк не работает, можно использовать LLM. Показать модели код API-вызова на фронте и список эндпоинтов на бэке, попросить выбрать наиболее вероятное соответствие. Модель: deepseek-r1 или Claude для высокого качества рассуждений.

---

## Оценка трудозатрат

TODO 3.1 (Структура графа): 2-3 дня — проектирование схемы, документация.

TODO 3.2 (Типы связей): 2-3 дня — определение связей, правила создания.

TODO 3.3 (Связывание фронт-бэк): 4-5 дней — сложный алгоритм с эвристиками.

TODO 3.4 (Построение графа): 3-4 дня — двухпроходный алгоритм, разрешение имён.

TODO 3.5 (Индексация): 2-3 дня — работа с Weaviate, оптимизация.

Общая оценка фазы: 2-3 недели.

---

## Критерии завершения фазы

Граф строится для тестовых репозиториев без ошибок. Связи между фронтом и бэком создаются с разумной точностью (>80% для типичных паттернов). Поиск по графу работает: можно найти функцию и получить её связи. Можно визуализировать граф для отладки (экспорт в формат для Gephi или аналога).
