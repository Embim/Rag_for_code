# Фаза 2. Загрузка и парсинг репозиториев

## Общее описание фазы

Эта фаза создаёт механизмы для работы с Git-репозиториями и извлечения структурированной информации из кода. Это сердце системы Code RAG — без качественного парсинга невозможно построить граф знаний и делать осмысленный поиск. Фаза включает универсальный загрузчик репозиториев и специализированные парсеры для Python (Django, FastAPI, DRF) и TypeScript/JavaScript (React).

Результат фазы — система умеет загружать репозитории, определять их тип и технологический стек, и извлекать из кода структурированные сущности: функции, классы, компоненты, эндпоинты, модели данных.

---

## TODO 2.1: Загрузчик репозиториев

### Что нужно сделать

Создать модуль, который умеет принимать Git-репозитории (по URL или локальному пути), клонировать их в рабочую директорию, фильтровать ненужные файлы, и предоставлять унифицированный доступ к содержимому.

### Источники репозиториев

Система должна поддерживать несколько способов указания репозитория. Публичный GitHub/GitLab URL вида https://github.com/user/repo.git клонируется напрямую. Приватный репозиторий требует настройки SSH-ключей или токена доступа, которые берутся из конфигурации. Локальный путь /path/to/repo используется как есть без клонирования.

### Фильтрация файлов

Большая часть файлов в репозитории не нужна для индексации. Node_modules в JavaScript-проекте может содержать сотни тысяч файлов, которые только замедляют обработку. Система должна игнорировать: директории с зависимостями (node_modules, vendor, venv, __pycache__), билд-артефакты (dist, build, .next, __pycache__), конфигурационные файлы системы контроля версий (.git), большие бинарные файлы, минифицированный код (*.min.js, *.bundle.js), lock-файлы (package-lock.json, poetry.lock).

Фильтрация настраивается через конфигурацию и может быть переопределена файлом .ragignore в корне репозитория (аналог .gitignore).

### Определение типа проекта

После загрузки система должна автоматически определить технологический стек. Признаки фронтенд-проекта на React: наличие package.json с зависимостью react, файлы с расширением .jsx или .tsx, директория src/components. Признаки Django-проекта: файл manage.py в корне, директория с settings.py, приложения с models.py и views.py. Признаки FastAPI: импорт from fastapi import FastAPI, декораторы @app.get/post.

Определение стека влияет на выбор парсеров и настройки индексации. Результат сохраняется в метаданных репозитория.

### Конфигурация репозитория

Пользователь может указать дополнительную информацию о репозитории: роль (frontend, backend, shared-library), основной фреймворк (если автоопределение ошиблось), точки входа (main.py, src/index.tsx), путь к OpenAPI-спецификации.

### Структура рабочей директории

Все репозитории клонируются в директорию data/repos/. Каждый репозиторий в своей поддиректории с именем, соответствующим конфигурации. Метаданные репозитория хранятся в data/repos/{name}/.rag-meta.json.

### Обработка ошибок

Клонирование может упасть по разным причинам: нет доступа, нет сети, недостаточно места на диске. Все ошибки должны логироваться с понятными сообщениями. При ошибке с одним репозиторием обработка других продолжается.

---

## TODO 2.2: Python AST-парсер

### Что нужно сделать

Создать парсер, который использует встроенный модуль ast Python для извлечения структуры кода: определения функций и классов, импорты, декораторы, docstrings, type hints.

### Почему именно AST

Регулярные выражения или простой текстовый анализ недостаточны для надёжного парсинга кода. AST (Abstract Syntax Tree) — это структурированное представление кода, которое Python строит при компиляции. Модуль ast позволяет обходить это дерево и извлекать информацию.

### Извлекаемые сущности

Для каждой функции: имя, список параметров с типами (если есть type hints), тип возвращаемого значения, docstring, декораторы, номера строк начала и конца, тело функции как текст.

Для каждого класса: имя, базовые классы (наследование), docstring, декораторы, список методов, список атрибутов класса.

Для импортов: что импортируется, откуда, алиасы. Это важно для построения графа зависимостей.

### Обработка ошибок парсинга

Синтаксически некорректный Python-файл не парсится через ast. Такие файлы нужно пропускать с логированием ошибки. Файлы с незначительными проблемами (неиспользуемые импорты, нарушения стиля) парсятся нормально — ast работает на синтаксическом уровне.

### Сохранение контекста

Для каждой сущности сохраняется контекст: в каком файле находится, в каком классе (для методов), какие импорты доступны в области видимости. Это нужно для правильного отображения кода пользователю и для связывания сущностей.

### Извлечение тела функции

Тело функции сохраняется как текст (не AST), потому что именно текст будет показываться пользователю и использоваться для embedding. AST используется для структурного анализа, текст — для отображения и поиска.

---

## TODO 2.3: Парсер Django

### Что нужно сделать

Создать специализированный парсер, который понимает структуру Django-проекта и извлекает Django-специфичные сущности: модели, вьюхи, URL-маршруты, формы, сериализаторы DRF.

### Архитектура

Django-парсер работает поверх базового Python-парсера. Сначала базовый парсер извлекает классы и функции, затем Django-парсер анализирует их и определяет, какие из них являются Django-сущностями.

### Парсинг моделей

Класс является Django-моделью, если наследуется от models.Model (или его подклассов). Для моделей извлекаются: имя модели, все поля с их типами (CharField, IntegerField, ForeignKey и т.д.), параметры полей (max_length, null, blank, related_name), методы модели, класс Meta с его параметрами.

Особое внимание на связи между моделями: ForeignKey, OneToOneField, ManyToManyField. Для каждой связи извлекается целевая модель и параметры связи. Это основа для построения ER-диаграмм и понимания структуры данных.

### Парсинг URL-конфигурации

Файл urls.py содержит маппинг URL-паттернов на обработчики. Парсер должен извлечь: паттерн URL (path или re_path), связанную view-функцию или класс, имя маршрута (name=), namespace для include().

Сложность в том, что URL-конфигурация может быть распределена по нескольким файлам через include(). Парсер должен следовать по include() и собирать полную картину маршрутизации.

### Парсинг views

View-функция — это функция, декорированная определённым образом или принимающая request как первый аргумент. View-класс — наследник View или его подклассов (TemplateView, ListView, CreateView).

Для каждой view извлекается: какие HTTP-методы обрабатывает (GET, POST), какой шаблон использует (template_name), какую модель использует (model), permissions и authentication.

### Django REST Framework

DRF добавляет свои сущности: ViewSet-ы, сериализаторы, permissions, filters. 

ViewSet — это класс, наследующий viewsets.ViewSet или его вариации (ModelViewSet, ReadOnlyModelViewSet). Для ViewSet извлекается: какая модель используется (queryset), какой сериализатор, какие actions доступны (list, create, retrieve, update, destroy, плюс кастомные через @action).

Serializer — класс, наследующий serializers.Serializer или ModelSerializer. Извлекаются поля, их типы, валидаторы, вложенные сериализаторы.

### Связывание с URL

Для DRF важно понять как ViewSet регистрируется в router и какие URL это создаёт. DefaultRouter автоматически создаёт набор URL для ViewSet (list, detail, и кастомные actions). Парсер должен уметь вычислять эти URL.

---

## TODO 2.4: Парсер FastAPI

### Что нужно сделать

Создать парсер, который извлекает структуру FastAPI-приложения: эндпоинты, их параметры, Pydantic-модели для request/response, зависимости.

### Поиск приложения FastAPI

FastAPI-приложение создаётся как app = FastAPI(). Парсер ищет такие присваивания и отслеживает переменную приложения. Она может называться app, application, api или иначе. Важно найти все места где на эту переменную вешаются декораторы маршрутов.

### Парсинг эндпоинтов

Эндпоинты определяются декораторами @app.get("/path"), @app.post("/path") и т.д. Для каждого эндпоинта извлекается: HTTP-метод, путь, параметры пути (в фигурных скобках), функция-обработчик.

Из функции-обработчика извлекаются: параметры с типами, параметры Query() и Path() с их описаниями и валидацией, параметры Body() для тела запроса, тип возвращаемого значения (response_model).

### Pydantic-модели

FastAPI использует Pydantic для валидации данных. Парсер должен извлекать Pydantic-модели (классы, наследующие BaseModel) со всеми их полями, типами, значениями по умолчанию, валидаторами.

Модели связываются с эндпоинтами: если эндпоинт принимает параметр с типом CreateUserRequest, и есть модель class CreateUserRequest(BaseModel), они связываются.

### Зависимости (Depends)

FastAPI активно использует Dependency Injection через Depends(). Парсер извлекает зависимости эндпоинтов: какие функции вызываются через Depends, что они возвращают. Типичные зависимости: get_current_user для аутентификации, get_db для сессии базы данных.

### APIRouter

Большие приложения разбивают эндпоинты по роутерам: router = APIRouter(prefix="/users"). Парсер должен отслеживать роутеры и учитывать их prefix при построении полных путей.

### OpenAPI-спецификация

FastAPI автоматически генерирует OpenAPI-спецификацию, доступную по /openapi.json. Если приложение можно запустить, эту спецификацию можно получить и использовать как источник истины вместо статического парсинга. Это опциональный режим для повышения точности.

---

## TODO 2.5: Парсер React/TypeScript

### Что нужно сделать

Создать парсер для React-приложений на TypeScript/JavaScript, извлекающий компоненты, хуки, API-вызовы, роутинг, управление состоянием.

### Технология парсинга

Python не имеет встроенного парсера для TypeScript. Варианты: использовать tree-sitter с грамматикой TypeScript (быстро, но требует компиляции нативного модуля), вызывать внешний Node.js скрипт с TypeScript compiler API (точнее, но медленнее), использовать babel parser через subprocess.

Рекомендуется tree-sitter как баланс скорости и точности. Библиотека py-tree-sitter позволяет использовать tree-sitter из Python.

### Парсинг компонентов React

React-компонент — это функция, возвращающая JSX, или класс, наследующий React.Component. Для функциональных компонентов (современный стандарт) извлекается: имя компонента, props с типами (из TypeScript-типизации), возвращаемый JSX (для понимания структуры UI).

### Props и их типы

В TypeScript props обычно типизированы: interface ButtonProps { label: string; onClick: () => void; }. Парсер извлекает эти интерфейсы/типы и связывает с компонентами. Это важно для понимания API компонента.

### Хуки

Использование хуков внутри компонента извлекается: useState, useEffect, useMemo, useCallback, и особенно важно — кастомные хуки и хуки для работы с данными (useQuery, useMutation из React Query).

### API-вызовы

Поиск всех мест где делаются HTTP-запросы. Паттерны: fetch("/api/..."), axios.get("/api/..."), useMutation с mutationFn, RTK Query endpoints. Для каждого вызова извлекается: URL (может быть динамическим), HTTP-метод, тело запроса, обработка ответа и ошибок.

URL может собираться динамически: `${API_URL}/users/${userId}`. Парсер должен распознавать такие паттерны и извлекать шаблон URL с переменными частями.

### React Router

Роутинг определяет какие компоненты показываются на каких URL. Парсер ищет использование Route, Routes, BrowserRouter и извлекает маппинг путей на компоненты. Это критично для визуализации — нужно знать на каком URL рендерится нужный компонент.

### Формы

Формы — ключевой элемент для многих вопросов. Парсер распознаёт использование React Hook Form (useForm, register, handleSubmit), Formik (useFormik, Form, Field), и простые controlled inputs. Извлекаются поля формы, их валидация, обработчик submit.

### State Management

Если используется Redux, Zustand или другое решение, парсер извлекает структуру store, actions, selectors. Это помогает понять как данные распределены между компонентами.

---

## Рекомендуемые технологии

### ast (Python standard library)

Для парсинга Python-кода. Встроен в Python, не требует зависимостей, хорошо документирован. Поддерживает все версии Python 3.x.

### tree-sitter с py-tree-sitter

Для парсинга TypeScript/JavaScript. Быстрый инкрементальный парсер, используется в редакторах кода. Требует установки tree-sitter-typescript grammar.

Установка: pip install tree-sitter, затем скачать и скомпилировать grammar для TypeScript.

### GitPython

Для работы с Git-репозиториями. Клонирование, получение diff, чтение истории коммитов.

### pathspec

Для работы с gitignore-подобными паттернами. Используется для фильтрации файлов по .ragignore.

---

## Модели ИИ для этой фазы

В этой фазе модели ИИ напрямую не используются — это чисто детерминированный парсинг кода. Однако есть опциональное использование:

### LLM для улучшения docstrings

Если у функции нет docstring, можно использовать LLM для генерации описания по коду. Это улучшит качество embeddings и поиска. Модель: любая быстрая модель для генерации текста, например deepseek-r1 через OpenRouter (как уже настроено в проекте) или локальная Qwen.

### LLM для определения типа проекта

В сложных случаях, когда автоопределение не справляется, можно показать LLM структуру директорий и несколько ключевых файлов и спросить какой это стек. Это fallback для edge cases.

---

## Оценка трудозатрат

TODO 2.1 (Загрузчик): 3-4 дня — работа с Git, фильтрация, определение типа.

TODO 2.2 (Python AST): 2-3 дня — базовый парсер на ast.

TODO 2.3 (Django): 4-5 дней — много специфики, DRF добавляет сложности.

TODO 2.4 (FastAPI): 3-4 дня — проще Django, но Pydantic и Depends требуют внимания.

TODO 2.5 (React/TS): 5-7 дней — сложность tree-sitter, много паттернов для распознавания.

Общая оценка фазы: 3-4 недели.

---

## Критерии завершения фазы

Система умеет клонировать репозитории по URL и работать с локальными путями. Автоопределение типа проекта работает для типичных Django, FastAPI, React проектов. Парсеры извлекают все основные сущности без потери информации. Синтаксически некорректные файлы не ломают индексацию. Написаны тесты с эталонными репозиториями для проверки качества парсинга.
